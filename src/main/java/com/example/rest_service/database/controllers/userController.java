package com.example.rest_service.database.controllers;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import com.example.rest_service.database.repositories.UserRepository;
import com.example.rest_service.database.entities.User;
import jakarta.servlet.http.HttpSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

// This means that this class is a Controller
@CrossOrigin(origins = "http://localhost:8081")
@RestController
@RequestMapping(path = "/user") // For me to refer to the base URL is https://localhost:8080/user
public class userController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    //JPA
    private UserRepository userRepository; // For my reference this is to talk to the database. If I'm not wrong

    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Autowired
    private JdbcTemplate jdbcTemplate; //This adds the jdbcTemplate that allows for raw SQL Queries

    /**
     * This is for Secure User Registration.
     * This method takes in a name, email, and password and saves a new user into the database.
     * Here we hash the password before we save, so that it's not store in plain text.
     */
//    @PostMapping(path = "/add") // Map ONLY POST Requests
    //@PostMapping("/register")
    @PostMapping("/add")
    public ResponseEntity<Map<String, String>> addNewUser(@RequestBody Map<String, String> request) {
        String userName = request.get("username");  // ✅ FIXED: Matches frontend field names
        String email = request.get("email");
        String password = request.get("password");
        String firstName = request.get("firstName"); // ✅ FIXED: Matches frontend
        String lastName = request.get("lastName");  // ✅ FIXED: Matches frontend

        if (userName == null || email == null || password == null) {
            return ResponseEntity.badRequest().body(Map.of("message", "Missing required fields."));
        }

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String hashedPassword = encoder.encode(password);

        String sql = "INSERT INTO user (user_name, email, password, first_name, last_name) VALUES (?, ?, ?, ?, ?)";
        jdbcTemplate.update(sql, userName, email, hashedPassword, firstName, lastName);

        return ResponseEntity.ok(Map.of("message", "User registered successfully!"));
    }


    // https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/oauth2/core/user/OAuth2User.html
    // https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/core/annotation/AuthenticationPrincipal.html
    // this path now simply handles logging in a user after authentication.
//    @PostMapping("/oauth2/google")
//    public @ResponseBody String googleLogin(@AuthenticationPrincipal OAuth2User user, HttpSession session) {
//        if (user == null) {
//            return "Error: Unable to authenticate with Google.";
//        }
//
//        String email = user.getAttribute("email");
//        // Check if the user already exists in the database using email. This is kind of redundant since a user will be
//        // I want to get the attributes from the actual database because a googleOAuth user may have changed their
//        // userName. If i just took the info from user.getAttribute("userName") it may not match anymore.
//        Optional<User> existingUser = userRepository.findByEmail(email);
//
//        if (existingUser.isPresent()) {
//            User userFromDb = existingUser.get();
//            session.setAttribute("userEmail", userFromDb.getEmail());
//            session.setAttribute("userName", userFromDb.getUserName());
//            session.setAttribute("isLoggedIn", true);
//            return "Google Login Successful! Welcome " + userFromDb.getUserName();
//        }
//
//        return "Error: Unable to authenticate with Google.";
//    }


    //Just for my reference queryForMap() is only for 1 row. queryForList() is for multiple queries
    @PostMapping("/login")
    public ResponseEntity<Map<String, String>> loginUser(@RequestBody Map<String, String> loginData, HttpSession session) {
        String email = loginData.get("email");
        String password = loginData.get("password");

        String sql = "SELECT id, user_name, password, first_name, last_name FROM user WHERE email = ?";
        try {
            Map<String, Object> userData = jdbcTemplate.queryForMap(sql, email);
            String userName = (String) userData.get("user_name");
            String firstName = (String) userData.get("first_name");  // ✅ Include first name
            String lastName = (String) userData.get("last_name");  // ✅ Include last name
            String hashedPassword = (String) userData.get("password");
            BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

            if (encoder.matches(password, hashedPassword)) {
                session.setAttribute("userEmail", email);
                session.setAttribute("userName", userName);
                session.setAttribute("firstName", firstName);
                session.setAttribute("lastName", lastName);
                session.setAttribute("isLoggedIn", true);

                return ResponseEntity.ok(Map.of(
                        "message", "Login successful",
                        "email", email,
                        "userName", userName,
                        "firstName", firstName,  // ✅ Include in response
                        "lastName", lastName     // ✅ Include in response
                ));
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body(Map.of("message", "Incorrect password. Please try again!"));
            }
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("message", "Error logging in. Please try again later."));
        }
    }

    @GetMapping("/logout")
    public @ResponseBody String logout(HttpSession session) {
        session.invalidate();
        return "Logged out successfully!";
    }

    // Get all users
    @GetMapping(path = "/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    //This is the admin get all users
    @GetMapping("/admin/all-users")
    public @ResponseBody Object getAllUsers(HttpSession session){
        if(!isAdmin(session)){
            return "Error: Unauthorized access. Please log in first";
        }

        String role = (String) session.getAttribute("userRole");

        if(role == null || !role.equals("ADMIN")){
            return "Error: Access denied. Admins only.";
        }

        return userRepository.findAll();
    }

    //This is the admin route to force create a new user. (Must be logged in as Admin)
    @PostMapping("/admin/create-user")
    public @ResponseBody String createUser(HttpSession session,
                                           @RequestParam String username,
                                           @RequestParam String email,
                                           @RequestParam String password,
                                           @RequestParam(required = false, defaultValue = "USER") String role) {
        if(!isAdmin(session)){
            return "Error: Access denied. Admins only.";
        }

        if(userRepository.findByEmail(email).isPresent()){
            return "Error: Email already exists.";
        }

        if(userRepository.findByUserName(username).isPresent()){
            return "Error: Username already exists.";
        }

        User newUser = new User();
        newUser.setUserName(username);
        newUser.setEmail(email);
        newUser.setPassword(passwordEncoder.encode(password));
        newUser.setRole(User.Role.valueOf(role.toUpperCase()));

        userRepository.save(newUser);
        return "New user created successfully!";

    }

    @GetMapping(path = "/{id}")
    public @ResponseBody User getUserById(@PathVariable Integer id) {
        return userRepository.findById(id).orElse(null);
    }

    @DeleteMapping("/admin/delete-user/{id}")
    public @ResponseBody String deleteUser(@PathVariable Integer id, HttpSession session) {
        if(!isAdmin(session)){
            return "Error: Access denied. Admins only.";
        }

        String checkSQL = "SELECT COUNT(*) FROM user where id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return "Error: user not found.";
        }

        String deleteSQL = "DELETE FROM user WHERE id = ?";
        jdbcTemplate.update(deleteSQL, id);

        return "User deleted successfully!";
    }

    //This updates the user role
    @PatchMapping("/admin/update-role/{id}")
    public @ResponseBody String updateUserRole(@PathVariable Integer id,
                                               @RequestParam String newRole,
                                               HttpSession session) {

        if(!isAdmin(session)){
            return "Error: Access denied. Admins only.";
        }

        String checkSQL = "SELECT COUNT(*) FROM user WHERE id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return "Error: User not found.";
        }

        String updateSQL = "UPDATE user SET role = ? WHERE id = ?";
        jdbcTemplate.update(updateSQL, newRole.toUpperCase(), id);

        return "User role updated successfully!";
    }

    //This is meant to disable the user account (Soft delete)
    @PatchMapping("/admin/disable-user/{id}")
    public @ResponseBody String disableUser(@PathVariable Integer id, HttpSession session) {
        if(!isAdmin(session)){
            return "Error: Access denied. Admins only.";
        }

        String checkSQL = "SELECT COUNT(*) FROM user WHERE id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return "Error: User not found.";
        }

        String disableSQL = "UPDATE user SET active = false WHERE id = ?";
        jdbcTemplate.update(disableSQL, id);

        return "User disabled successfully!";
    }


    //A helper method to identify whether user is logged in as an admin or not.
    private boolean isAdmin(HttpSession session) {
        if (session.getAttribute("isLoggedIn") == null || !(boolean) session.getAttribute("isLoggedIn")) {
            return false; // User is not logged in
        }

        String role = (String) session.getAttribute("userRole");
        return role != null && role.equals("ADMIN");
    }

    @GetMapping("/details")
    public ResponseEntity<Map<String, String>> getUserDetails(@RequestParam(required = true) String email) {
        if (email == null || email.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("message", "Invalid email provided."));
        }

        String sql = "SELECT user_name, first_name, last_name FROM user WHERE email = ?";
        try {
            List<Map<String, Object>> results = jdbcTemplate.queryForList(sql, email);
            if (results.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(Map.of("message", "User not found"));
            }

            Map<String, Object> userData = results.get(0);
            return ResponseEntity.ok(Map.of(
                    "userName", (String) userData.get("user_name"),
                    "firstName", (String) userData.get("first_name"),
                    "lastName", (String) userData.get("last_name")
            ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("message", "Error retrieving user details"));
        }
    }

    @GetMapping("/getUserId")
    public ResponseEntity<?> getUserIdByEmail(@RequestParam String email) {
        Optional<User> user = userRepository.findByEmail(email);

        if (user.isPresent()) {
            return ResponseEntity.ok(Map.of("userId", user.get().getId()));
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "User not found"));
        }
    }
}