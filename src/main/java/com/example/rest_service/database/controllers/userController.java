package com.example.rest_service.database.controllers;

import com.example.rest_service.database.repositories.UserRepository;
import com.example.rest_service.database.entities.User;
import jakarta.servlet.http.HttpSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.Optional;

// This means that this class is a Controller
@Controller
@RequestMapping(path = "/user") // For me to refer to the base URL is https://localhost:8080/user
public class userController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    //JPA
    private UserRepository userRepository; // For my reference this is to talk to the database. If I'm not wrong

    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Autowired
    private JdbcTemplate jdbcTemplate; //This adds the jdbcTemplate that allows for raw SQL Queries

    /**
     * This is for Secure User Registration.
     * This method takes in a name, email, and password and saves a new user into the database.
     * Here we hash the password before we save, so that it's not store in plain text.
     */
//    @PostMapping(path = "/add") // Map ONLY POST Requests
    @PostMapping("/register")
    public ResponseEntity<Object> addNewUser(@RequestParam String user_name,
                                           @RequestParam String email,
                                           @RequestParam String password,
                                           @RequestParam (required = false) String first_name,
                                           @RequestParam (required = false) String last_name) {

        Optional<User> existingUser = userRepository.findByEmail(email);
        if (existingUser.isPresent()) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of("error", "Email already exists."));
        }

        Optional<User> existingUserName = userRepository.findByUserName(user_name);

        if (existingUserName.isPresent()) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of("error", "Username already exists."));
        }

        //Here we create a new user object
        User n = new User();
        n.setUserName(user_name);
        n.setEmail(email);
        n.setFirstName(first_name);
        n.setLastName(last_name);

        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        //At this point we now have a hashed password no longer in plain text
        String hashedPassword = encoder.encode(password);

        n.setPassword(hashedPassword); //Here we are now using the new secure password.

        n.setRole(User.Role.USER);

        //Here we save the User into the database.
        userRepository.save(n);
        return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "User registered successfully!"));
    }

    // https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/oauth2/core/user/OAuth2User.html
    // https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/core/annotation/AuthenticationPrincipal.html
    // this path now simply handles logging in a user after authentication.
    @PostMapping("/oauth2/google")
    public @ResponseBody String googleLogin(@AuthenticationPrincipal OAuth2User user, HttpSession session) {
        if (user == null) {
            return "Error: Unable to authenticate with Google.";
        }

        String email = user.getAttribute("email");
        // Check if the user already exists in the database using email. This is kind of redundant since a user will be
        // I want to get the attributes from the actual database because a googleOAuth user may have changed their
        // userName. If i just took the info from user.getAttribute("userName") it may not match anymore.
        Optional<User> existingUser = userRepository.findByEmail(email);

        if (existingUser.isPresent()) {
            User userFromDb = existingUser.get();
            session.setAttribute("userEmail", userFromDb.getEmail());
            session.setAttribute("userName", userFromDb.getUserName());
            session.setAttribute("isLoggedIn", true);
            return "Google Login Successful! Welcome " + userFromDb.getUserName();
        }

        return "Error: Unable to authenticate with Google.";
    }


    //Just for my reference queryForMap() is only for 1 row. queryForList() is for multiple queries
    @PostMapping("/login") //This is the route for user login
    public ResponseEntity<Object> loginUser(@RequestParam String email, @RequestParam String password, HttpSession session) {
        String sql = "SELECT id, user_name, password, first_name, last_name, role FROM user WHERE email = ?";

        try {
            //This executes the SQL query using the "queryForMap()"
            //It is then returned as a map with Map<String, Object) where:
            //Each **COLUMN** name from the database is **KEY** in the Map.
            //Each **COLUMN VALUE** (from the database row) is stored as a **value** in the Map.
            Map<String, Object> userData = jdbcTemplate.queryForMap(sql, email);
            // Example: If the database has this row:
            // | id | user_name | email       | password |
            // | 1  | John     | John@example | #$#@$##$ |
            // Therefore "queryForMap(sql, "John@example.com")" will return:
            // userData = {
            //    "id": 1,
            //    "user_name": "John",
            //    "password": #$#@$##$
            //} This is my understanding of this.

            String userName = (String) userData.get("user_name");
            String hashedPassword = (String) userData.get("password");
            String firstName = (String) userData.get("first_name");
            String lastName = (String) userData.get("last_name");
            String role = (String) userData.get("role"); //This is to get the user role

            BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

            if (encoder.matches(password, hashedPassword)) {
                session.setAttribute("userEmail", email);
                session.setAttribute("userName", userName);
                session.setAttribute("userRole", role);
                session.setAttribute("isLoggedIn", true);
                return ResponseEntity.ok(Map.of("message", "Login successful! Welcome " + userData.get("user_name")));
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("error", "Incorrect password."));
            }

        } catch (Exception e) {
            System.out.println("Error: " + e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Error logging in. Please try again later."));
        }
    }


    @GetMapping("/logout")
    public ResponseEntity<Object> logout(HttpSession session) {
        session.invalidate();
        return ResponseEntity.ok(Map.of("message", "Logged out successfully!"));
    }

    // Get all users
    @GetMapping(path = "/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    //This is the admin get all users
    @GetMapping("/admin/all-users")
    public @ResponseBody Object getAllUsers(HttpSession session){
        if(!isAdmin(session)){
            return "Error: Unauthorized access. Please log in first";
        }

        String role = (String) session.getAttribute("userRole");

        if(role == null || !role.equals("ADMIN")){
            return "Error: Access denied. Admins only.";
        }

        return userRepository.findAll();
    }

    //This is the admin route to force create a new user. (Must be logged in as Admin)
    @PostMapping("/admin/create-user")
    public ResponseEntity<Object> createUser(HttpSession session,
                                            @RequestParam String username,
                                            @RequestParam String email,
                                            @RequestParam String password,
                                            @RequestParam(required = false, defaultValue = "USER") String role) {
        if(!isAdmin(session)){
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("error", "Access denied. Admins only."));
        }

        if(userRepository.findByEmail(email).isPresent()){
            return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of("error", "Email already exists."));}

        if(userRepository.findByUserName(username).isPresent()){
            return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of("error", "Username already exists."));
        }

        User newUser = new User();
        newUser.setUserName(username);
        newUser.setEmail(email);
        newUser.setPassword(passwordEncoder.encode(password));
        newUser.setRole(User.Role.valueOf(role.toUpperCase()));

        userRepository.save(newUser);
        return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "New user created successfully!"));
    }

    @GetMapping(path = "/{id}")
    public @ResponseBody User getUserById(@PathVariable Integer id) {
        return userRepository.findById(id).orElse(null);
    }

    @DeleteMapping("/admin/delete-user/{id}")
    public ResponseEntity<Object>  deleteUser(@PathVariable Integer id, HttpSession session) {
        if(!isAdmin(session)){
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("error", "Access denied. Admins only."));
        }

        String checkSQL = "SELECT COUNT(*) FROM user where id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "User not found."));
        }

        String deleteSQL = "DELETE FROM user WHERE id = ?";
        jdbcTemplate.update(deleteSQL, id);

        return ResponseEntity.ok(Map.of("message", "User deleted successfully!"));
    }

    //This updates the user role
    @PatchMapping("/admin/update-role/{id}")
    public ResponseEntity<Object> updateUserRole(@PathVariable Integer id,
                                               @RequestParam String newRole,
                                               HttpSession session) {

        if(!isAdmin(session)){
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("error", "Access denied. Admins only."));
        }

        String checkSQL = "SELECT COUNT(*) FROM user WHERE id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "User not found."));
        }

        String updateSQL = "UPDATE user SET role = ? WHERE id = ?";
        jdbcTemplate.update(updateSQL, newRole.toUpperCase(), id);

        return ResponseEntity.ok(Map.of("message", "User role updated successfully!"));
    }

    //This is meant to disable the user account (Soft delete)
    @PatchMapping("/admin/disable-user/{id}")
    public ResponseEntity<Object> disableUser(@PathVariable Integer id, HttpSession session) {
        if(!isAdmin(session)){
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("error", "Access denied. Admins only."));
        }

        String checkSQL = "SELECT COUNT(*) FROM user WHERE id = ?";
        Integer count = jdbcTemplate.queryForObject(checkSQL, Integer.class, id);
        if(count == null || count == 0){
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "User not found."));
        }

        String disableSQL = "UPDATE user SET active = false WHERE id = ?";
        jdbcTemplate.update(disableSQL, id);

        return ResponseEntity.ok(Map.of("message", "User disabled successfully!"));
    }


    //A helper method to identify whether user is logged in as an admin or not.
    private boolean isAdmin(HttpSession session) {
        if (session.getAttribute("isLoggedIn") == null || !(boolean) session.getAttribute("isLoggedIn")) {
            return false; // User is not logged in
        }

        String role = (String) session.getAttribute("userRole");
        return role != null && role.equals("ADMIN");
    }

}